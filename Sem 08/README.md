# Динамична памет
### В една C++ програма най-общо казано има 3 вида памет
- статична - в нея се съхраняват всички променливи, декларирани извън тялото на функция, т.е. глобалните променливи.
- стекова - в нея се съхраняват всички функции, променливите, дефинирани в тях, и информация за извикването на функциите под формата на така наречените *стекови рамки*. Статичната памет още се нарича и "автоматична", защото
заделената памет автоматично се изтрива при излизането от областта на видимост (scope), в който е заделена
- динамична - останалата част от паметта на компютъра е достъпна за всички програми при поискване. За управлението на тази памет се грижи операционната система. Във всеки момент отделен блок от паметта може да е свободен или да е заделен за някоя програма и може да го чете само тя. 

### Разлики между стекова и динамична памет
- стековата памет се заделя ПО ВРЕМЕ на компилацията на програмата, докато динамичната памет се заделя по време на изпълнение на програмата
- стековата памет се освобождава при излизането от scope-a, в който е заделена, докато динамичната памет трябва да се изтрие ръчно

### new expression
Заделя динамична памет и връща указател към нея
```c++
int* arr = new int[n];
```

### Оператор delete
Понеже динамичната памет не се освобождава автоматично, се налага ние да е маркираме като свободна ръчно. Това се постига чрез оператор delete:
```c++
int* arr = new int[n];
delete[] arr;
```

### Memory leak
Нека разгледаме следния код:
```c++
void f(unsigned size)
{
    int newSize = size + 1;

    int* arr = new int[newSize];
    for (int i = 0; i < newSize; i++)
    {
        arr[i] = i;
        cout << arr[i];
    }
}

int main()
{
    f(10);
}
```

Тук ще се изчисти паметта, заделена за извикването на функцията в стека, но динамичната памет, заделена за масива arr няма да се изчисти. След излизане от функцията вече нямаме достъп до указателя към динамичната памет и няма как да я изтрием.
Такива случаи са грешки и се наричат *memory leaks*. В такъв случай трябва да изчистим ръчно паметта:
```c++
void f(unsigned size)
{
    int newSize = size + 1;

    int* arr = new int[newSize];
    for (int i = 0; i < newSize; i++)
    {
        arr[i] = i;
        cout << arr[i];
    }
    delete[] arr; // !!!
}

int main()
{
    f(10);
}
```

## Задачи
### Примери от семинар
**1.** Напишете функция, която приема символен низ и връща нов низ, за който е заделено точно количество памет, който представлява копие на оригиналния низ, в който обаче всички числа са заменени с '*'.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>test123example2test4</td><i><td>test*example*test*</td></i></tr>
</table>

**2.** Напишете функция, която приема символен низ и връща 2 нови низа с точно количество памет - един, съставен само от малките букви в низа и един, съставен само от главните буква в низа.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>A river there, Chief!</td><i><td>AC</br> rivertherehief</td></i></tr>
</table>

**3.** Напишете функция, която приема символен низ и връща нови низ с точно количество памет, съставен само от малките букви от низа в сортиран вид.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>1d83aazc</td><i><td>aacdz</td></i></tr>
</table>

### Още задачи
**1 (partition).** Напишете функция, която приема масив от цели числа и елемент от масива и размества елементите на масива по такъв начин, че всички по-малки елементи от подадения елемент да са вляво от него, а всички по-големи - вдясно от него. За решението използвайте допълнителен масив (има и решение, което не използва допълнителна памет - Lomuto partition)
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>5 13 6 9 12 11 8 </br> 9</td><i><td>5 6 8 9 12 11 13 </td></i></tr>
</table>
