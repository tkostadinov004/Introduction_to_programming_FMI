# Рекурсия
Рекурсивна функция наричаме такава функция, която извиква себе си пряко или косвено.
### Случаи
Решаването на задача рекурсивно изисква да можем да намерим нейната *рекурсивната декомпозиция*. Рекурсивна декомпозиция наричаме това как се решава даден проблем чрез по-малки негови инстанции. Трябва ни също и поне едно
*дъно на рекурсията* - това е случай, който се изчислява без рекурсивно извикване. Рекурсивната декомпозиция трябва за крайно време да се сведе до дъно на рекурсията. </br> </br>
Нека погледнем алгоритъмът за изчисляване на факториел на числото $`n`$: </br>
$`n\:!=\begin{cases} n \:*\: (n - 1)\:!, \: \: n \gt 0 \\ 1, \: \: n = 0   \end{cases}`$ </br> </br>
Тук рекурсивна декомпозиция се явява първия случай ($`n \:*\: (n - 1)\:!, \: \: n \gt 0`$), понеже той описва решаване на проблема за изчисляване на факториел чрез извикване на същата функция, но с по-малък вход от оригиналния.
Дъно пък се явява втория случай, тъй като той не се изчислява чрез рекурсивно извикване. Очевидно е, че понеже на всяка стъпка $`n`$ се намалява с 1, за крайно време ще се стигне до това $`n`$ да е 0, тоест ще се достигне до дъното. </br>
Изчислението за $`n = 5`$ ще стане по следния начин: </br>
$`\displaylines{5! \\ = 5 * (4!) \\  = 5 * (4 * (3!)) \\  = 5 * (4 * (3 * (2!))) \\  = 5 * (4 * (3 * (2 * (1!))))  \\ = 5 * (4 * (3 * (2 * (1 * (0!)))))  \\ = 5 * (4 * (3 * (2 * (1 * (1)))))  \\ = 5 * (4 * (3 * (2 * (1))))  \\ = 5 * (4 * (3 * (2)))  \\ = 5 * (4 * (6))  \\ = 5 * (24)  \\ = 120}`$

#### Повече от едно дъно?
Нека погледнем функцията за изчисление на N-тото число на Фибоначи (започвайки от 0), където $`Fib(n)`$ ще бъде $`n`$-тото число на Фибоначи. Намираме рекурсивната декомпозиция и дъното: </br>
$`Fib(n) = \begin{cases} Fib(n - 1) + Fib(n - 2), \: \: n \ge 2 \\ 1, \: \: иначе \end{cases}`$ </br>
Тук имаме две дъна, а именно при $`n = 0`$ и $`n = 1`$. Изчислението за $`n = 5`$ ще стане по следния начин: </br>
$`\displaylines{Fib(5) \\ = Fib(4) + Fib(3) \\ = (Fib(3) + Fib(2)) + (Fib(2) + Fib(1)) \\ = ((Fib(2) + Fib(1)) + (Fib(1) + Fib(0))) + ((Fib(1) + Fib(0)) + 1) \\ = (((Fib(1) + Fib(0)) + 1) + (1 + 1)) + ((1 + 1) + 1) \\ = (((1 + 1) + 1) + 2) + ((2) + 1) \\ = (((2) + 1) + 2) + (3) \\ = (((3) + 2)) + (3) \\ = (5) + (3) \\ = 8}`$

## Мемоизация
Когато решаваме някои задачи можем да забележим, че имаме много еднотипни рекурсивни извиквания. Например при пресмятането на 5-тото число на Фибоначи по-горе можем да видим, че извикването за намиране на второто число на Фибоначи става 3 пъти и на всеки от трите пъти ще се извика рекурсивно намирането на второто и първото число на Фибоначи. За малки входове това не създава особено голямо забавяне, но при случаи като например намирането на 50-тото число на Фибоначи, ще имаме множество извиквания за намиране на 25-тото число на Фибоначи например, което от своя страна ще поражда още еднотипни пресмятания, които евентуално вече сме извършили и няма смисъл да извършваме пак. </br>

Тук на помощ идва концепция, наречена ***мемоизация*** - да запазваме вече изчислените стойности в някаква структура от данни по наш избор (в курса по УП ще използваме масив за тази цел). Мемоизация има смисъл да се използва, ако има много повторения в пресмятанията. </br> 

Функцията за намиране на число на Фибоначи има следния вид:
```c++
unsigned fib(unsigned n, unsigned* mem)
{
   if (mem[n] != 0)
   {
      return mem[n];
   }
   return mem[n] = fib(n - 1) + fib(n - 2);
}

int main()
{
   unsigned n;
   cin >> n;

   unsigned* mem = new unsigned[n + 1]{0};
   mem[0] = mem[1] = 1;

   cout << fib(n, mem);
   delete[] mem; // !!!
}
```
По такъв начин няма да се налага да се смята повторно fib(10) след като вече е било сметнато 1 път, понеже винаги, когато се извика fib(10) ще видим, че тази стойност вече е сметната и ще я вземем директно от масива, вместо отново да викаме fib(9) + fib(8) = ...

## Симулиране на итеративен процес чрез рекурсия
Има много видове рекурсия, но сега ще се концентрираме върху опашковата рекурсия. Това е рекурсивна функция, при която последното действие на функцията е рекурсивно извикване. 
</br>
Нека например погледнем две решения на задачата за намиране на сумата на всички числа от 1 до N: 
```c++
unsigned sum(unsigned x)
{
   if (x == 0)
   {
      return 0;
   }
   return x + sum(x - 1);
}

unsigned sumTail(unsigned x, unsigned sum)
{
   if (x == 0)
   {
      return sum;
   }
   return sumTail(x - 1, sum + x);
}

int main()
{
   unsigned n;
   cin >> n;

   cout << sum(n) << endl << sumTail(n, 0) << endl; 
}
```
Разглеждаме случая за n = 5. Изпълнението на функцията *sum* ще има следния вид: </br>
$`\displaylines{sum(5) \\ = 5 + sum(4) \\ = 5 + (4 + sum(3)) \\ = 5 + (4 + (3 + sum(2))) \\ = 5 + (4 + (3 + (2 + sum(1)))) \\ = 5 + (4 + (3 + (2 + (1 + sum(0))))) \\ = 5 + (4 + (3 + (2 + (1 + 0)))) \\ = 5 + (4 + (3 + (2 + (1)))) \\ = 5 + (4 + (3 + (3))) \\ = 5 + (4 + (6)) \\ = 5 + (10) \\ = 15}`$ </br>
Изпълнението на функцията *sumTail* ще има следния вид: </br>
$`\displaylines{sumTail(5, 0) \\ = sumTail(4, 5) \\ = sumTail(3, 9) \\ = sumTail(2, 12) \\ = sumTail(1, 14) \\ = sumTail(0, 15) \\ = 15}`$

## Задачи
### Примери от семинар
**1.** Напишете функция, която приема естествено число и изчислява факториел от него.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>5</td><i><td>120</td></i></tr>
   <tr><td>0</td><i><td>1</td></i></tr>
</table>

**2.** Напишете функция, която приема естествено число N и изчислява N-тото число на Фибоначи (започвайки от 0). Решете задачата със и без мемоизация.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>5</td><i><td>8</td></i></tr>
</table>

**3.** *Двоична експоненциация* е трик, често използван в състезателното програмиране, който ни позволява да изчисляваме по-бързо степени от вида $`a^n`$. Наивният подход за повдигане на степен представлява умножение на числото $`a`$   $`n`$ пъти - $`a^n = a \cdot a \cdot a ... a`$. Този подход обаче не е подходящ за много големи числа.</br>Нека напишем числото $`n`$ в двоична бройна система. 
Например,</br>$`3^{13} = 3^{1101_2} = 3^{1000_2 + 0100_2 + 0001_2} = 3^{1000_2} \cdot 3^{0100_2} \cdot 3^{0001_2} =3^8 \cdot 3^4 \cdot 3^1`$. 
Понеже $`n`$ има $`\lfloor \log_2 n \rfloor + 1`$ на брой цифри, ще трябва да извършим $`log_2(n)`$ пресмятания, вместо $`n`$. Всяко число в двоична бройна система може да се образува като сбор от степени на двойката. 
</br> Например, числото $`13 ={1101_2}`$ може да се запише като $`{1101_2} = {1000_2} + {0100_2} + {0001_2} = 8 + 4 + 1`$. </br></br> Изчислението е дадено по следния начин:</br></br>
$`a^n = \begin{cases}
1 &\text{, ако } n = 0 \\
\left(a^2\right)^{\frac{n}{2}} &\text{, ако } n > 0 \text{ и } n \text{ е четно}\\
a \cdot \left(a^{n-1}\right) &\text{, ако } n > 0 \text{ и } n \text{ е нечетно}\\
\end{cases}`$</br></br>
Напишете функция, която изчислява степента $`a^n`$, където $`a`$ е естествено число и $`n`$ е цяло число. Решете задачата рекурсивно, вместо итеративно
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>3 </br> 10</td><td><i>59049</i></td></tr>
</table>

**4.** Напишете функция, която приема число N и връща за колко най-малко стъпки от N до 1, чрез следните операции: намаляване с 1, деление на 2, деление на 3. Решете задачата чрез мемоизация.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th><th><strong>Обяснение</strong></th></tr>
   <tr><td>5</td><i><td>3</td></i><td>От 5 до 1 можем да стигнем с най-малко 3 стъпки - начините са следните: </br> <ul><li>намаляваме 5 с 1 и получаваме 4; делим 4 на 2 и получаваме 2; делим 2 на 2 и получаваме 1</li><li>намаляваме 5 с 1 и получаваме 4; делим 4 на 2 и получаваме 2; намаляваме 2 с 1 и получаваме 1</li></ul></td></tr>
</table>

**5.** Напишете функция, която приема масив и даден елемент и връща индекса му в масива, ако се съдържа, или -1, ако не се съдържа.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>10 9 8 7 6 </br> 8</td><i><td>2</td></i></tr>
   <tr><td>1 3 2 </br> 4</td><i><td>-1</td></i></tr>
</table>

**6.** Напишете функция, която приема ***сортиран във възходящ ред*** масив и даден елемент и връща индекса му в масива, ако се съдържа, или -1, ако не се съдържа.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>6 7 8 9 10 </br> 8</td><i><td>2</td></i></tr>
   <tr><td>1 2 3 </br> 4</td><i><td>-1</td></i></tr>
</table>

**7.** Напишете функция, която приема символен низ и проверява дали той е палиндром.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>tacocat</td><i><td>true</td></i></tr>
   <tr><td>test</td><i><td>false</td></i></tr>
</table>

**8.** Напишете функция, която приема символен низ и връща сумата на всички числа в него.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>ab37c10x</td><i><td>47</td></i></tr>
</table>

**9.** Напишете функция, която приема символен низ и символ и връща дължината на най-дългата последователност от дадения символ в низа.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td><i>aaabc</i><strong>aaaa</strong>df </br> a</td><i><td>4</td></i></tr>
</table>

## Още задачи
**1.** Напишете функция, която приема число N и принтира всички булеви вектори с дължина N.
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>3</td><i><td>000 </br> 001 </br> 010 </br> 011</br> 100</br> 101</br> 110</br> 111 </td></i></tr>
</table>
