# Цикли - for, while, do-while
Нека разгледаме следната изключително проста задача: </br></br>
*Принтирайте всички естествени числа от 1 до 5.* </br></br>
Естествено, можем да направим следното:
```c++
std::cout << 1 << std::endl << 2 << std::endl << 3 << std::endl << 4 << std::endl << 5;
```
Нека сега малко променим условието: </br></br>
*Въвежда се естествено число N. Нека се принтират всички естествени числа от 1 до N.* </br></br>
Тук, за разлика от предния пример, не знаем колко точно е горната граница, до която да принтираме. Затова ще се наложи да видим всеки един вариант за числото n, който потребителят би въвел някога. Не са много, само **4,294,967,295** (2^32 - 1) варианта са :)
```c++
unsigned n;
std::cin >> n;

if (n == 1) {
    std::cout << 1;
} else if (n == 2) {
    std::cout << 1 << 2;
} else if (n == 3) {
    std::cout << 1 << 2 << 3;
}
и така нататък до else if (n == 4294967295) {
    std::cout << 1 << 2 << 3 << много мъки по-късно... << 4294967295;
}
```
Трябва да има по-лесен начин - когато пишем дадена програма би било изключително удобно да изпълняваме дадено парче код много пъти, докато дадено условие е вярно. Това ще ни спести писането на горе-долу **4,294,967,295** на брой напълно еднакви неща. </br>
Интуитивно, решението би било нещо от сорта: </br> 
```c++
unsigned n = ...;
unsigned current = 1;
принтирай current и го увеличавай с 1. прави това, докато current е по-малко или равно от n
``` 
В С++ съществуват такива средства за изпълнение на парчета код до достигането на определено условие и те се наричат **цикли**.
### while
Синтаксис: 
```c++
while (<условие>)
{
    // кодът тук ще се изпълнява, докато <условие> е истина
}
```
Решението на задачата горе с while цикъл би станала по следния начин (с номерирани редове):
```c++
1) unsigned n;
2) std::cin >> n;
3) 
4) unsigned current = 1;
5) while (current <= n)
6) {
7)     std::cout << current;
8)     current++;
9) }
```
Редове 7 и 8 ще се изпълняват, докато условието в скобите е вярно, тоест стойността на *current* не е достигнала n. Затова е важно да увеличаваме стойността на *current*, за да може тя все някога да достигне тази на n и цикълът да спре да се изпълнява.

## Задачи
### Примери от семинар
**1.** Напишете програма, която чете две цели числа от конзолата и намира тяхното най-малко общо кратно (НОК).</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>10 </br> 4</td><td><i>20</i></td></tr>
   <tr><td>12 </br> 6</td><td><i>12</i></td></tr>
</table>

**2.** Напишете програма, която чете две цели числа от конзолата и намира техния най-голям общ делител (НОД).</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>25 </br> 10</td><td><i>5</i></td></tr>
   <tr><td>17 </br> 6</td><td><i>1</i></td></tr>
</table>

### Още задачи
**1.** Напишете програма, която чете естествено число и обръща цифрите на числото.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>14478</td><td><i>87441</i></td></tr>
   <tr><td>1001</td><td><i>1001</i></td></tr>
</table>

**2.** Напишете програма, която чете цяло число n и n на брой цифри. Нека програмата образува числото, съставено само от четните цифри, които са прочетени.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>5 </br> 2 3 1 8 4</td><td><i>284</i></td></tr>
   <tr><td>4 </br> 1 6 4 3</td><td><i>64</i></td></tr>
</table>
