# Бройни системи. Указатели. Символни низове
## Бройни системи.
<table>
  <thead>
    <tr>
      <th>Десетична (decimal)</th>
      <th>Двоична (binary)</th>
      <th>Осмична (octal)</th>
      <th>Шестнайсетична (hexadecimal)</th>
      <th>Унарна (unary)</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>00</td><td>00000</td><td>00</td><td>00</td><td>00001</td></tr>
    <tr><td>01</td><td>00001</td><td>01</td><td>01</td><td>00011</td></tr>
    <tr><td>02</td><td>00010</td><td>02</td><td>02</td><td>00111</td></tr>
    <tr><td>03</td><td>00011</td><td>03</td><td>03</td><td>01111</td></tr>
    <tr><td>04</td><td>00100</td><td>04</td><td>04</td><td>...</td></tr>
    <tr><td>05</td><td>00101</td><td>05</td><td>05</td><td></td></tr>
    <tr><td>06</td><td>00110</td><td>06</td><td>06</td><td></td></tr>
    <tr><td>07</td><td>00111</td><td>07</td><td>07</td><td></td></tr>
    <tr><td>08</td><td>01000</td><td>10</td><td>08</td><td></td></tr>
    <tr><td>09</td><td>01001</td><td>11</td><td>09</td><td></td></tr>
    <tr><td>10</td><td>01010</td><td>12</td><td>0A</td><td></td></tr>
    <tr><td>11</td><td>01011</td><td>13</td><td>0B</td><td></td></tr>
    <tr><td>12</td><td>01100</td><td>14</td><td>0C</td><td></td></tr>
    <tr><td>13</td><td>01101</td><td>15</td><td>0D</td><td></td></tr>
    <tr><td>14</td><td>01110</td><td>16</td><td>0E</td><td></td></tr>
    <tr><td>15</td><td>01111</td><td>17</td><td>0F</td><td></td></tr>
    <tr><td>16</td><td>10000</td><td>20</td><td>10</td><td></td></tr>
  </tbody>
</table>

### Преобразуване между бройни системи
 - алгоритъм за преобразуване от произволна бройна система в десетична бройна система
 - алгоритъм за преобразуване от десетична бройна система в произволна бройна система

## Въведение в указателите
Указателят от даден тип е променлива, която сочи към адрес на друга променлива в паметта.
### Оператор &
- приема променлива от тип Т и връща указател от тип T*

Пример:
```c++
int a = 10;
int* b = &a;
```
### Оператор * (оператор за дерефериране)
- приема указател от тип T* и връща променлива от тип Т

Пример:
```c++
int a = 10;
int* b = &a;

int c = *b;
cout << c; // 10
```
### Какви са разликите между указател и референция?
- не може да променяме това накъде сочи една референция, докато при указателите можем
```c++
int a = 5;
int b = 10;

int& c = a;
c = b; // това е валиден синтаксис, но няма да се промени променливата, към която сочи 'c', а напротив - понеже 'c' е псевдоним на 'a',
       // това което ще стане е, че 'a' ще придобие стойността на 'b' и референцията 'c' ще продължи да сочи към 'a'

int* ptr = &a;
ptr = b; // тук ще се смени адреса в паметта, към който сочи 'ptr', и стойностите на 'a' и 'b' няма да се променят по никакъв начин
```
- референцията трябва да се инициализира при създаването си, докато при указателите това не е задължително
```c++
int a = 10;

int& ref; // syntax error

int* ptr; // ок
ptr = &a; 
```
- указателите имат неутрална стойност, а референцията няма
```c++
int* ptr = nullptr; // тази специална стойност показва, че указателят не сочи към нищо
```
- можем да правим масиви от указатели, но не и масиви от референции
```c++
int a = 3, b = 4, c = 5;

int* arr[3] = {&a, &b, &c}; // ок
int& arr[3] = {a, b, c}; // syntax error
```

### Относно размера на указателите
Както разбрахме по-горе, указателите също са променливи и като такива те също имат някакъв размер в паметта. </br> </br>
***⚠️ Всички указатели имат еднакъв размер, без значение от типа им. Този размер е 4 байта при 32-битова архитектура и 8 байта при 64-битова архитектура.***

### Указателна аритметика
#### Оператор sizeof
Операторът sizeof се използва, за да вземем размера в байтове на дадена променлива или тип.
```c++
cout << sizeof(int) << endl; // 4 (не е задължително, но в рамките на курса ще приемаме, че е толкова

char letter = 'a';
cout << sizeof(letter) << endl; // 1
```

sizeof на указатели връща размера на указателя, а не на типа променливи, към които може да сочи той:
```c++
int* intPtr = nullptr;
double* doublePtr = nullptr;
char* charPtr = nullptr;

cout << sizeof(intPtr) << endl; // 8 (ако приемем, че работим на 64-битова архитектура)
cout << sizeof(doublePtr) << endl; // 8 (ако приемем, че работим на 64-битова архитектура)
cout << sizeof(charPtr) << endl; // 8 (ако приемем, че работим на 64-битова архитектура)
```
#### Сметки
В C++ можем да извършваме аритметични операции с адреси в паметта. </br>
Всяка инкрементация или декрементация на указател увеличава или намалява адреса, към който сочи той, със sizeof(*типа на указателя*):
```c++
int a = 10; // нека приемем, че е на адрес 200 в паметта

int* ptr = &a; // сочи към адрес 200
++ptr; // вече сочи към адрес 204
++ptr; // вече сочи към адрес 208
++ptr; // вече сочи към адрес 212
--ptr; // вече сочи към адрес 208
```
Всяко увеличение или намаляване с число i увеличава или намалява адреса, към който сочи указателя, със ```i * sizeof(типа на указателя)```:
```c++
int a = 10; // нека приемем, че е на адрес 200 в паметта

int* ptr = &a; // сочи към адрес 200
ptr + 1 // сочи към адрес 200 + 1 * sizeof(int) = 204
ptr + 2 // сочи към адрес 200 + 2 * sizeof(int) = 208
ptr + 3 // сочи към адрес 200 + 3 * sizeof(int) = 212
ptr - 1 // сочи към адрес 200 - 1 * sizeof(int) = 196
```
Можем и да пресметнем разликата между 2 указателя, като резултатът от това ще бъде разликата от двата адреса, разделена на размера на типа на указателя:
```c++
int a = 5; // нека приемем, че е на адрес 200 в паметта
int b = 10; // нека приемем, че е на адрес 220 в паметта

int* aPtr = &a; // сочи към адрес 200
int* bPtr = &b; // сочи към адрес 220

int diff = bPtr - aPtr;
cout << diff; // 5 = (220 - 200) / sizeof(int)
```
Естествено, ако имаме указатели към началото и към края на един масив, можем по този начин да пресметнем точно колко елемента има в него. Както е по-горе, началото на масива ще е на адрес 200, а края - на адрес 220. Тогава
броя на елементите в него ще бъде ```(220 - 200) / sizeof(int) + 1```.

### Подаване на масиви във функции
Както разбрахме от предишни семинари, масивът представлява указател към първия елемент в него. Това означава, че можем да подаваме във функции масиви там, където се изисква указател:
```c++
void print(const int* arr, unsigned size)
{
    for (unsigned i = 0; i < size; i++)
    {
        cout << arr[i] << " ";
    }
}

int main()
{
    constexpr unsigned SIZE = 5;
    int arr[SIZE] = {1, 2, 3, 4, 5};

    print(arr, SIZE); // 1 2 3 4 5
}
```

### int* vs const int* vs int const* vs int * const vs const int * const
Всички тези привидно объркващи съчетания от ключови думи означават следното:
- int* ptr означава "ptr е указател към променлива от тип int"
- const int* ptr и int const* ptr означават "ptr е указател към константна променлива от тип int" (тоест може да се променя накъде сочи указателя, но не може да се променя самата стойност на променливата, към която сочи)
- int * const ptr означава "ptr е константен указател към променлива от тип int" (тоест НЕ може да се променя накъде сочи указателя, но може да се променя самата стойност на променливата, към която сочи)
- const int * const ptr означава "ptr е константен указател към константна променлива от тип int" (тоест НЕ може да се променя накъде сочи указателя и НЕ може да се променя самата стойност на променливата, към която сочи)

Един трик за по-лесно запомняне е да се чете израза отдясно наляво: </br>
**const int\* const ptr** може да се прочете като "ptr е константен указател към int, който е константен"

## Символни низове
Символният низ е масив от символи, който има някъде в себе си специален символ, наречен *сентинел*, който се явява край на низа.
```c++
char str[] = {'f', 'm', 'i', '\0'};
char str1[] = "fmi";
char str[6] = "fmi";
```
### Подаване във функции
Символният низ е най-обикновен масив, тоест представлява указател към първия символ в него, и можем да го подаваме на функции, както бихме подали други масиви.
```c++
void f(const char* str)
{
    // something
}

int main()
{
  char str[] = "fmi";
  f(str);
}
```
### Относно принтирането
Когато принтираме масиви, които не са от тип char, ще се принтира адреса на първия елемент. Ако принтираме масиви от тип char ще се принтират всички символи до срещането на първата терминираща нула.
```c++
int arr[] = {1, 2, 3};
cout << arr; // адрес на първия елемент

char str[] = "fmi";
cout << str; // fmi
```
 
## Задачи
### Примери от семинар
**1.** Напишете функция, която приема символен низ и даден символ и връща колко пъти се среща той в низа.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>g<strong>oo</strong>d m<strong>o</strong>rning </br> o</td><i><td>3</td></i></tr>
</table>

**2 (strlen).** Напишете функция, която приема символен низ и връща броя на символите в него (без терминиращата нула). </br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>fmi</td><i><td>3</td></i></tr>
</table>

**3.** Напишете функция, която приема символен низ, символ *find* и символ *replace* и замества всяко срещане на *find* с *replace*.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>good morning </br> o </br> s</td><i><td>gssd msrning</td></i></tr>
</table>

**4 (strcpy).** Напишете функция, която приема два символни низа и копира съдържанието на втория низ в първия (приемаме, че в първия има достатъчно място). </br>
<table>
   <tr><th><strong>Извикване</strong></th></tr>
   <tr>
     <td>
       char str[100]; </br>
       copyStr(str, "fmi"); </br>
       cout << str; // fmi
     </td>
   </tr>
</table>
         
**5 (strcat).** Напишете функция, която приема два символни низа и долепя съдържанието на втория низ към това на първия (приемаме, че в първия има достатъчно място). </br>
<table>
   <tr><th><strong>Извикване</strong></th></tr>
   <tr>
     <td>
       char str[100] = "fmi"; </br>
       concatenate(str, "up"); </br>
       cout << str; // fmiup
     </td>
   </tr>
</table>

**6 (strcmp).** Напишете функция, която приема два символни низа и ги сравнява лексикографски, като връща отрицателна стойност, ако първият низ е лексикографски по-малък от втория; 0, ако са лексикографски равни; положителна стойност, ако първият низ е лексикографски по-голям от втория.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>fmi </br> fni</td><i><td>-1</td></i></tr>
   <tr><td>fmi </br> fmi</td><i><td>0</td></i></tr>
   <tr><td>zebra </br> fmi</td><i><td>20</td></i></tr>
</table>

**7 (atoi).** Напишете функция, която приема символен низ, който може да съдържа число в себе си, и връща числовата стойност.</br>
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th><th><strong>Уточнение</strong></th></tr>
   <tr><td>123 </td><i><td>123</td></i><td>Ще се върне самото число и ще можем да направим нещо от сорта: </br> int num = parse("123"); </br> cout << num; // 123 </br> num++; </br> cout << num; // 124</td></tr>
   <tr><td>fmi</td><i><td>-1</td></i><td></td></tr>
   <tr><td>fm12i45</td><i><td>12</td></i><td></td></tr>
</table>

### Още задачи
**1.** Напишете функция, която приема символен низ и превръща всички главни букви в малки и всички малки букви в главни. 
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>i fought THE LAW and... the LaW WON</td><i><td>I FOUGHT the law AND... THE lAw won</td></i></tr>
</table>

**2.** Наричаме едно изречение *анаграма* на друго, ако едното изречение може да се образува чрез разместване на символите на другото изречение. При проверката дали едно изречение е анаграма на друго, игнорирайте всички символи, които не са букви, и не правете разлика между малки и големи букви. По този начин изречението "Astronomer?!" е анаграма на "Moon starter.", понеже и двете имат по еднакъв брой от всяка буква.</br>
Напишете функция, която приема два символни низа, представляващи изречения и връща дали първото изречение е анаграма на второто.
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>Astronomer?! </br> Moon starter.</td><i><td>true</td></i></tr>
   <tr><td>ground control</br> major tom</td><i><td>false</td></i></tr>
</table>

**3.** Напишете функция, която приема символен низ и връща броя на думите в него. 
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>This is an example!</td><i><td>4</td></i></tr>
   <tr><td>This is an example with a &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long break! ?!?!</td><i><td>8</td></i></tr>
</table>

**4.** Напишете функция, която приема символен низ и връща дали той представлява валиден IPv4 адрес. 
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th></tr>
   <tr><td>192.168.0.1</td><i><td>true</td></i></tr>
   <tr><td>192.168.256.1</td><i><td>false</td></i></tr>
   <tr><td>0.0.0..</td><i><td>false</td></i></tr>
</table>

**5.** Напишете функция, която приема символен низ, съставен само от малки букви, и проверява дали съществува пермутация на този низ, която да е палиндром.
<table>
   <tr><th><strong>Вход</strong></th><th><strong>Изход</strong></th><th><strong>Обяснение</strong></th></tr>
   <tr><td>oxoox</td><i><td>true</td></i><td>Възможни пермутации, които са палиндроми, са xooox и oxoxo</td></tr>
   <tr><td>abac</td><i><td>false</td></i><td></td></tr>
</table>
